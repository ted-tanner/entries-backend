## End-to-End Encryption model and zero-trust access

This server is transport and storage only. All user data objects (containers, entries, categories, user keystores and preferences) are opaque encrypted blobs. The server never sees plaintext. It enforces only generic invariants (object sizes, version nonces, key lifetimes) and verifies possession of the right cryptographic tokens.

Core primitives:
- Container access keys: Each container maintains a set of Ed25519 public keys. A client proves access by presenting a `ContainerAccessToken` that was signed with the corresponding private key. The server verifies the signature using the stored public key. Read-only keys are supported.
- Invitation accept keys: Sharing uses a temporary Ed25519 keypair generated by the server per invitation. The server encrypts the private key and related metadata for the recipient with the recipient’s RSA public key. The recipient presents a `ContainerAcceptToken` signed by that temporary private key to accept/decline.
- User auth tokens: User authentication and session are HMAC-SHA256 tokens (`AuthToken`) signed by the server. Types: Access, Refresh, SignIn, UserDeletion.

Zero-trust property: The server does not track which user can access which container. For any container operation, the client provides a container-specific token signed by the proper private key. The server verifies it using the matching stored public key. Sharing is possible because the sender gives the recipient material (encrypted by the recipient’s public key) that allows the recipient to later prove access, still without the server tracking an ACL.

All request/response bodies for the API (except HTML deletion pages and JSON health) use Protocol Buffers encoded with `Content-Type: application/protobuf`.

## Getting started: user lifecycle

1) Create user
- Endpoint: POST `/api/user`
- Body: `NewUser` (protobuf). Contains email, client-hashed auth string, hash params, recovery parameters, encrypted account key, initial user public RSA key id and value, and initial encrypted preferences and keystore blobs.
- Response: 201 Created with `SigninToken { value }`.
- After this, an OTP email is sent immediately to allow the user to complete sign-in and verify their account.

2) Verify OTP to get session tokens and verify user email
- POST `/api/auth/otp/verify`
- Headers: `SignInToken: <token from step 1>`
- Body: `Otp { value }` (from email)
- Response: `AuthenticatedSession { tokens: TokenPair { access_token, refresh_token, server_time }, preferences_encrypted, preferences_version_nonce, user_keystore_encrypted, user_keystore_version_nonce, password_encryption_key_salt, password_encryption_key_mem_cost_kib, password_encryption_key_threads, password_encryption_key_iterations, encryption_key_encrypted_with_password }`
- Successful OTP verification marks the account as verified.

3) Sign in
- Obtain per-user auth-string params and a nonce:
  - GET `/api/auth/nonce-and-auth-string-params?email=<email>`
  - Response: `SigninNonceAndHashParams { auth_string_hash_salt, auth_string_hash_mem_cost_kib, auth_string_hash_threads, auth_string_hash_iterations, nonce }`
- Compute client-side hash with the returned nonce, then request a sign-in token:
  - POST `/api/auth/sign-in` with body `CredentialPair { email, auth_string, nonce }`
  - Response: `SigninToken { value }` and an email OTP is sent to the user.
- Note: Unverified users can sign in; they will be auto-verified upon successful OTP verification (see step 2).

4) Resend OTP during sign-in (if needed)
- POST `/api/auth/otp/resend-signin-otp`
- Headers: `SignInToken: <token from sign-in>`
- Response: 200 OK (new OTP email is sent)

5) Refresh tokens
- POST `/api/auth/token/refresh`
- Headers: `RefreshToken: <refresh_token>`
- Response: `TokenPair { access_token, refresh_token, server_time }`

6) Logout (blacklist refresh token)
- POST `/api/auth/logout`
- Headers: `AccessToken: <access_token>`, `RefreshToken: <refresh_token>`
- Response: 200 OK


## Getting started: sharing containers

This section gives a practical, step-by-step flow for sharing a container between two verified users. The crypto formats for info blobs are client-defined; the server only stores opaque bytes and verifies tokens.

- Prerequisites
  - Sender has an `AccessToken` and a read-write `ContainerAccessToken` for the container
  - Sender knows the container's encryption key (to share) and container id
  - Recipient has a verified account with a registered RSA public key

- Sender workflow
  1) Fetch recipient's public key
     - GET `/api/user/public-key?email=<recipient>` (Headers: `AccessToken`)
     - Response: `UserPublicKey { id, value }` where `value` is the recipient’s RSA public key (DER)
  2) Prepare encrypted artifacts (client-defined schemas)
     - Encrypt the container encryption key with recipient’s RSA public key → `encryption_key_encrypted`
     - Generate a random symmetric key; encrypt:
       - `container_info_encrypted` (e.g., container id/name and any metadata you want to show)
       - `sender_info_encrypted` (e.g., sender display name/email)
     - Encrypt the symmetric key with recipient’s RSA public key → `share_info_symmetric_key_encrypted`
  3) Create the invitation
     - POST `/api/container/invitation`
       - Headers: `AccessToken`, `ContainerAccessToken`
       - Body: `UserInvitationToContainer` with fields:
         - `recipient_user_email`: recipient email
         - `recipient_public_key_id_used_by_sender`: id from step 1
         - `recipient_public_key_id_used_by_server`: same id (unless you have a reason to reference a different stored key)
         - `sender_public_key`: your Ed25519 verifying key to authorize future retraction
         - `encryption_key_encrypted`, `container_info_encrypted`, `sender_info_encrypted`, `share_info_symmetric_key_encrypted`
         - `expiration`, `read_only`
     - Response: `InvitationId { value }`
  4) (Optional) Retract the invitation
     - Build `ContainerInviteSenderToken` claims `{ iid, exp }` and sign with the Ed25519 private key that matches `sender_public_key`
     - DELETE `/api/container/invitation` with Headers: `AccessToken`, `ContainerInviteSenderToken`

- Recipient workflow
  1) List pending invitations
     - GET `/api/container/invitation/all-pending` (Headers: `AccessToken`)
     - Response: `ContainerShareInviteList { invites: [...] }`, where each invite contains:
       - `container_accept_key_encrypted`, `container_accept_key_id_encrypted`, `container_accept_key_info_encrypted`
       - `container_info_encrypted`, `sender_info_encrypted`, `share_info_symmetric_key_encrypted`
       - `recipient_public_key_id_used_by_sender`, `recipient_public_key_id_used_by_server`, and the invite `id`
  2) Decrypt artifacts using recipient’s RSA private key
     - Decrypt `share_info_symmetric_key_encrypted` → symmetric key
     - Decrypt `container_info_encrypted` and `sender_info_encrypted` with symmetric key
     - Decrypt `container_accept_key_encrypted` → Ed25519 accept private key
     - Decrypt `container_accept_key_id_encrypted` → accept key id
     - Decrypt `container_accept_key_info_encrypted` → `AcceptKeyInfo { read_only, expiration }`
  3) Construct a `ContainerAcceptToken`
     - Claims: `{ iid: invitation id, kid: accept key id, cid: container id, exp: expiration }`
     - Sign claims with the accept private key (Ed25519)
  4) Accept the invitation
     - PUT `/api/container/invitation/accept`
       - Headers: `AccessToken`, `ContainerAcceptToken`
       - Body: `PublicKey { value }` with the recipient’s container user public key to attach
       - Response: `ContainerIdAndEncryptionKey { container_id, container_access_key_id, encryption_key_encrypted, read_only }`
     - Decrypt `encryption_key_encrypted` with RSA to obtain the container encryption key
  5) Or decline
     - PUT `/api/container/invitation/decline` with Headers: `AccessToken`, `ContainerAcceptToken`

After acceptance, the recipient can generate their own `ContainerAccessToken` (see section above) using the newly attached container access key and start performing container operations.


## Containers, entries, and categories

- All container operations require a user `AccessToken` header and, for container-scoped operations, a `ContainerAccessToken` proving access to that specific container. The server verifies the container token using the stored public key for the identified key id and container id. Some endpoints additionally enforce read-write access (not read-only).

- List/get containers
  - GET `/api/container`
  - Headers: `AccessToken`
  - Body: `ContainerAccessTokenList { tokens: [ContainerAccessToken] }`
  - Response: `ContainerList { containers: [Container] }`

- Create container
  - POST `/api/container`
  - Headers: `AccessToken`
  - Body: `NewContainer { encrypted_blob, version_nonce, categories: [CategoryWithTempId], user_public_container_key }`
  - Response: 201 Created with `Container`

- Update container metadata
  - PUT `/api/container`
  - Headers: `AccessToken`, `ContainerAccessToken`
  - Body: `EncryptedBlobUpdate { encrypted_blob, version_nonce, expected_previous_version_nonce }`
  - Response: 200 OK (requires non-read-only container access)

### Entries
- Create entry
  - POST `/api/container/entry`
  - Headers: `AccessToken`, `ContainerAccessToken`
  - Body: `EncryptedBlobAndCategoryId { encrypted_blob, version_nonce, category_id? }`
  - Response: 201 Created with `EntryId`

- Edit entry
  - PUT `/api/container/entry`
  - Headers: `AccessToken`, `ContainerAccessToken`
  - Body: `EntryUpdate { entry_id, encrypted_blob, version_nonce, expected_previous_version_nonce, category_id? }`
  - Response: 200 OK

- Delete entry
  - DELETE `/api/container/entry`
  - Headers: `AccessToken`, `ContainerAccessToken`
  - Body: `EntryId { value }`
  - Response: 200 OK

### Categories
- Create category
  - POST `/api/container/category`
  - Headers: `AccessToken`, `ContainerAccessToken`
  - Body: `NewEncryptedBlob { value, version_nonce }`
  - Response: 201 Created with `CategoryId`

- Edit category
  - PUT `/api/container/category`
  - Headers: `AccessToken`, `ContainerAccessToken`
  - Body: `CategoryUpdate { category_id, encrypted_blob, version_nonce, expected_previous_version_nonce }`
  - Response: 200 OK

- Delete category
  - DELETE `/api/container/category`
  - Headers: `AccessToken`, `ContainerAccessToken`
  - Body: `CategoryId { value }`
  - Response: 200 OK

- Create entry and category atomically
  - POST `/api/container/entry-and-category`
  - Headers: `AccessToken`, `ContainerAccessToken`
  - Body: `EntryAndCategory { entry_encrypted_blob, entry_version_nonce, category_encrypted_blob, category_version_nonce }`
  - Response: 201 Created with `EntryIdAndCategoryId`

- Leave container
  - DELETE `/api/container/leave`
  - Headers: `AccessToken`, `ContainerAccessToken`
  - Response: 200 OK (requires valid read access)

## Sharing containers

- Invite user to container
  - POST `/api/container/invitation`
  - Headers: `AccessToken`, `ContainerAccessToken` (must be non-read-only)
  - Body: `UserInvitationToContainer { recipient_user_email, recipient_public_key_id_used_by_sender, recipient_public_key_id_used_by_server, sender_public_key, encryption_key_encrypted, container_info_encrypted, sender_info_encrypted, share_info_symmetric_key_encrypted, expiration, read_only }`
  - Response: 200 OK with `InvitationId { value }`

- Retract invitation
  - DELETE `/api/container/invitation`
  - Headers: `AccessToken`, `ContainerInviteSenderToken`
  - Response: 200 OK

- Accept invitation
  - PUT `/api/container/invitation/accept`
  - Headers: `AccessToken`, `ContainerAcceptToken`
  - Body: `PublicKey { value }` (recipient’s container user public key)
  - Response: `ContainerIdAndEncryptionKey { container_id, container_access_key_id, encryption_key_encrypted, read_only }`

- Decline invitation
  - PUT `/api/container/invitation/decline`
  - Headers: `AccessToken`, `ContainerAcceptToken`
  - Response: 200 OK

- List all pending invitations for the current user
  - GET `/api/container/invitation/all-pending`
  - Headers: `AccessToken`
  - Response: `ContainerShareInviteList { invites: [ContainerShareInvite] }`

## User profile and security

- Lookup user public key
  - GET `/api/user/public-key?email=<email>`
  - Headers: `AccessToken`
  - Response: `UserPublicKey { id, value }`

- Rotate user public key
  - PUT `/api/user/public-key`
  - Headers: `AccessToken`
  - Body: `NewUserPublicKey { id, value, expected_previous_public_key_id }`
  - Response: 200 OK

- Edit user preferences
  - PUT `/api/user/preferences`
  - Headers: `AccessToken`
  - Body: `EncryptedBlobUpdate`
  - Response: 200 OK

- Edit user keystore
  - PUT `/api/user/keystore`
  - Headers: `AccessToken`
  - Body: `EncryptedBlobUpdate`
  - Response: 200 OK

- Change password (email + OTP gated)
  - PUT `/api/user/password`
  - Body: `AuthStringAndEncryptedPasswordUpdate { user_email, otp, new_auth_string, auth_string_hash_salt, auth_string_hash_mem_cost_kib, auth_string_hash_threads, auth_string_hash_iterations, password_encryption_key_salt, password_encryption_key_mem_cost_kib, password_encryption_key_threads, password_encryption_key_iterations, encrypted_encryption_key }`
  - Response: 200 OK

- Change recovery key (requires AccessToken)
  - PUT `/api/user/recovery-key`
  - Headers: `AccessToken`
  - Body: `RecoveryKeyUpdate { otp, recovery_key_hash_salt_for_encryption, recovery_key_hash_salt_for_recovery_auth, recovery_key_hash_mem_cost_kib, recovery_key_hash_threads, recovery_key_hash_iterations, recovery_key_auth_hash, encrypted_encryption_key }`
  - Response: 200 OK

- Change email (requires AccessToken)
  - PUT `/api/user/email`
  - Headers: `AccessToken`
  - Body: `EmailChangeRequest { new_email, auth_string }` (auth_string proves possession of password)
  - Response: 200 OK

- Initiate account deletion (emails link)
  - DELETE `/api/user`
  - Headers: `AccessToken`
  - Body: `ContainerAccessTokenList { tokens }` for containers the user wants scheduled for key cleanup
  - Response: `VerificationEmailSent { email_sent, email_token_lifetime_hours }`

- Confirm deletion (from emailed link)
  - GET `/api/user/deletion/verify?UserDeletionToken=<token>`
  - Response: HTML 200 or HTML error page

- Check deletion status
  - GET `/api/user/deletion`
  - Headers: `AccessToken`
  - Response: `IsUserListedForDeletion { value }`

- Cancel deletion
  - DELETE `/api/user/deletion`
  - Headers: `AccessToken`
  - Response: 200 OK

## Authentication endpoints (detail)

- GET `/api/auth/nonce-and-auth-string-params`
  - Query: `email`
  - Response: `SigninNonceAndHashParams`

- POST `/api/auth/sign-in`
  - Body: `CredentialPair`
  - Response: `SigninToken` (OTP email sent)

- POST `/api/auth/otp/verify`
  - Headers: `SignInToken`
  - Body: `Otp`
  - Response: `AuthenticatedSession` (includes `TokenPair` and user data; auto-verifies unverified accounts)

- POST `/api/auth/otp/resend-signin-otp`
  - Headers: `SignInToken`
  - Response: 200 OK (new OTP email sent)

- GET `/api/auth/otp`
  - Headers: `AccessToken`
  - Response: 200 OK (sends OTP email; body is empty)

- POST `/api/auth/token/refresh`
  - Headers: `RefreshToken`
  - Response: `TokenPair`

- POST `/api/auth/recover-with-recovery-key`
  - Body: `RecoveryKeyAuthAndPasswordUpdate`
  - Response: 200 OK (updates password, optional email, and re-encrypted keys)

- POST `/api/auth/logout`
  - Headers: `AccessToken`, `RefreshToken`
  - Response: 200 OK

## Health endpoints

- GET `/heartbeat`
  - Response: 200 OK, empty body
- GET `/health`
  - Query: `key=<admin-api-key>` (required)
  - Response: JSON `{ db_thread_pool_state: { connections, idle_connections, max_connections } }`
  - Note: **Admin-only endpoint**. Requires `ENTRIES_HEALTH_ENDPOINT_KEY` as the query parameter. Should be called infrequently as it queries database connection pool state.

## Client error reporting

- POST `/api/client-errors`
  - Body: Plain text error message (max 128 bytes, truncated if longer)
  - Response: 200 OK
  - Note: No authentication required. Clients can report errors encountered during normal operation.

- GET `/api/client-errors`
  - Query: `key=<admin-api-key>` (required)
  - Response: JSON array of `{ msg: string, timestamp_ms: u64 }` sorted by `timestamp_ms` descending
  - Note: **Admin-only endpoint**. Requires `ENTRIES_CLIENT_ERRORS_ENDPOINT_KEY` as the query parameter. Should be called infrequently as it snapshots the entire error log buffer, which requires locking every shard in the buffer. Returns all available entries.

## Protobuf messages

Refer to `protobuf/schema.proto` for definitions.

## Headers summary

- AccessToken: HMAC auth token (type Access) identifying the user; required for most authenticated endpoints.
- RefreshToken: HMAC auth token (type Refresh) used only for refresh and logout.
- SignInToken: HMAC auth token (type SignIn) used to verify OTP and obtain session tokens.
- ContainerAccessToken: Ed25519-signed token proving access to a specific container key id and container id.
- ContainerInviteSenderToken: Ed25519-signed token used by the inviter to retract an invitation.
- ContainerAcceptToken: Ed25519-signed token used by the invitee to accept/decline an invitation.
- Content-Type: application/protobuf for protobuf bodies.

## Error model

All protobuf endpoints return `ServerErrorResponse { err_type, err_message }` with appropriate HTTP codes on failure. Common error enums include: INCORRECTLY_FORMED, INVALID_MESSAGE, OUT_OF_DATE, INVALID_STATE, MISSING_HEADER, CONFLICT_WITH_EXISTING, INCORRECT_CREDENTIAL, TOKEN_EXPIRED, TOKEN_MISSING, WRONG_TOKEN_TYPE, USER_DISALLOWED, PENDING_ACTION, READ_ONLY_ACCESS, INVITATION_DOES_NOT_EXIST/ENTRY_DOES_NOT_EXIST/CATEGORY_DOES_NOT_EXIST/CONTAINER_DOES_NOT_EXIST/USER_DOES_NOT_EXIST, INPUT_TOO_LARGE, TOO_MANY_REQUESTED, INTERNAL_ERROR.

## Generating a ContainerAccessToken (client-side)

The server does not mint container access tokens. Clients generate them using the Ed25519 private key corresponding to a container access key stored on the server.

- Inputs
  - key_id (UUID): the container access key id
  - container_id (UUID)
  - expiration (u64 Unix seconds) in the future
  - Ed25519 private signing key that matches the server-stored public key for `key_id`

- Steps
  1. Build claims JSON with field names exactly as used by the server: `{ "kid": key_id, "bid": container_id, "exp": expiration }`.
  2. Encode claims to UTF-8 bytes.
  3. Sign those bytes with your Ed25519 private key to get a 64-byte signature.
  4. Concatenate bytes: `claims_json_bytes || signature_bytes`.
  5. Base64 URL-safe encode the concatenated bytes. Use the resulting string as the `ContainerAccessToken` header value.

- Header usage
  - Send on requests that operate on a container: `ContainerAccessToken: <token>`

- Rust example

```rust
use ed25519_dalek::{SigningKey, Signer};
use serde::Serialize;
use base64::engine::general_purpose::URL_SAFE as b64_urlsafe;
use base64::Engine;
use uuid::Uuid;

#[derive(Serialize)]
struct Claims {
    #[serde(rename = "kid")] key_id: Uuid,
    #[serde(rename = "bid")] container_id: Uuid,
    #[serde(rename = "exp")] expiration: u64,
}

fn make_container_access_token(
    signing_key: &SigningKey,
    key_id: Uuid,
    container_id: Uuid,
    expiration: u64,
) -> String {
    let claims = Claims { key_id, container_id, expiration };
    let mut json = serde_json::to_vec(&claims).unwrap();
    let sig = signing_key.sign(&json).to_bytes();
    json.extend_from_slice(&sig);
    b64_urlsafe.encode(json)
}
```

Notes:
- The server verifies the token by decoding Base64 (URL-safe), splitting JSON and signature, checking the Ed25519 signature against the stored public key for `key_id`, and ensuring `exp` is in the future and the `bid` matches the targeted container.
- Prefer short lifetimes for tokens; generate per request or cache briefly client-side.
