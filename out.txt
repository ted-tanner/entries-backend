 
 ### Minimum Viable Product
 
+* Enable serde `"rc"` feature and accept an `Arc<str>` (or perhaps `Rc<str>`) instead of a `String` for inputs (same with `Arc<[u8]>` instead of `Vec<u8>`)
+* Budget create endpoint needs to return access key id
 * Combine endpoints (/budget/create, /budget/get, /budget/edit can just be /budget POST, GET, PUT)
 * Unit tests!
   - [x] Jobs
diff --git a/entries-server/src/handlers/auth.rs b/entries-server/src/handlers/auth.rs
index 8ab62b0..3856474 100644
--- a/entries-server/src/handlers/auth.rs
+++ b/entries-server/src/handlers/auth.rs
@@ -39,7 +39,7 @@ pub async fn obtain_nonce_and_auth_string_params(
     let random: u64 = rng.gen();
 
     let mut hasher = Sha256::new();
-    hasher.update(&email.email);
+    hasher.update(&*email.email);
     hasher.update(random.to_be_bytes());
     let hash = hasher.finalize();
 
@@ -145,7 +145,7 @@ pub async fn sign_in(
 
     handlers::verification::verify_auth_string(
         &credentials.auth_string,
-        &credentials.email,
+        Arc::clone(&credentials.email),
         &db_thread_pool,
     )
     .await?;
@@ -164,7 +164,7 @@ pub async fn sign_in(
     };
 
     handlers::verification::generate_and_email_otp(
-        &credentials.email,
+        Arc::clone(&credentials.email),
         db_thread_pool.as_ref(),
         smtp_thread_pool.as_ref(),
     )
@@ -187,7 +187,12 @@ pub async fn verify_otp_for_signin(
         .enforce(&user_id, "verify_otp_for_signin", &db_thread_pool)
         .await?;
 
-    handlers::verification::verify_otp(&otp.otp, &claims.user_email, &db_thread_pool).await?;
+    handlers::verification::verify_otp(
+        Arc::clone(&otp.otp),
+        (&*claims.user_email).into(),
+        &db_thread_pool,
+    )
+    .await?;
 
     let now = SystemTime::now();
 
@@ -233,7 +238,7 @@ pub async fn obtain_otp(
         .await?;
 
     handlers::verification::generate_and_email_otp(
-        &user_access_token.0.user_email,
+        user_access_token.0.user_email.into(),
         db_thread_pool.as_ref(),
         smtp_thread_pool.as_ref(),
     )
@@ -314,8 +319,12 @@ pub async fn regenerate_backup_codes(
         .enforce(&user_id, "regenerate_backup_codes", &db_thread_pool)
         .await?;
 
-    handlers::verification::verify_otp(&otp.otp, &user_access_token.0.user_email, &db_thread_pool)
-        .await?;
+    handlers::verification::verify_otp(
+        Arc::clone(&otp.otp),
+        user_access_token.0.user_email.into(),
+        &db_thread_pool,
+    )
+    .await?;
 
     let backup_codes = Arc::new(Otp::generate_multiple(12, 8));
     let backup_codes_ref = Arc::clone(&backup_codes);
diff --git a/entries-server/src/handlers/budget.rs b/entries-server/src/handlers/budget.rs
index e2ee699..0027671 100644
--- a/entries-server/src/handlers/budget.rs
+++ b/entries-server/src/handlers/budget.rs
@@ -248,7 +248,7 @@ pub async fn invite_user(
 
     verify_read_write_access(&budget_access_token, &db_thread_pool).await?;
 
-    if invitation_info.recipient_user_email == user_access_token.0.user_email {
+    if invitation_info.recipient_user_email == user_access_token.0.user_email.into() {
         return Err(HttpErrorResponse::InvalidState(
             "Inviter and recipient are the same",
         ));
diff --git a/entries-server/src/handlers/mod.rs b/entries-server/src/handlers/mod.rs
index 3e018ee..0f31b75 100644
--- a/entries-server/src/handlers/mod.rs
+++ b/entries-server/src/handlers/mod.rs
@@ -12,26 +12,25 @@ pub mod verification {
     use std::sync::Arc;
     use std::time::SystemTime;
     use tokio::sync::oneshot;
-    use zeroize::Zeroize;
+    use zeroize::Zeroizing;
 
     use super::error::HttpErrorResponse;
     use crate::env;
 
     pub async fn generate_and_email_otp(
-        user_email: &str,
+        user_email: Arc<str>,
         db_thread_pool: &DbThreadPool,
         smtp_thread_pool: &EmailSender,
     ) -> Result<(), HttpErrorResponse> {
         let otp_expiration = SystemTime::now() + env::CONF.lifetimes.otp_lifetime;
 
-        let user_email = Arc::new(String::from(user_email));
         let user_email_ref = Arc::clone(&user_email);
 
-        let otp = Otp::generate(8);
-        let otp_clone = otp.clone();
+        let otp = Arc::new(Otp::generate(8));
+        let otp_ref = Arc::clone(&otp);
 
         let mut auth_dao = db::auth::Dao::new(db_thread_pool);
-        match web::block(move || auth_dao.save_otp(&otp_clone, &user_email_ref, otp_expiration))
+        match web::block(move || auth_dao.save_otp(&otp_ref, &user_email_ref, otp_expiration))
             .await?
         {
             Ok(a) => a,
@@ -67,8 +66,8 @@ pub mod verification {
     }
 
     pub async fn verify_otp(
-        otp: &str,
-        user_email: &str,
+        otp: Arc<str>,
+        user_email: Arc<str>,
         db_thread_pool: &DbThreadPool,
     ) -> Result<(), HttpErrorResponse> {
         const WRONG_OR_EXPIRED_OTP_MSG: &str = "OTP was incorrect or has expired";
@@ -79,9 +78,6 @@ pub mod verification {
             ));
         }
 
-        let otp = Arc::new(String::from(otp));
-        let user_email = Arc::new(String::from(user_email));
-
         let otp_ref = Arc::clone(&otp);
         let user_email_ref = Arc::clone(&user_email);
 
@@ -116,7 +112,7 @@ pub mod verification {
 
     pub async fn verify_auth_string(
         auth_string: &[u8],
-        user_email: &str,
+        user_email: Arc<str>,
         db_thread_pool: &DbThreadPool,
     ) -> Result<(), HttpErrorResponse> {
         if user_email.len() > 255 || auth_string.len() > 512 {
@@ -125,8 +121,7 @@ pub mod verification {
             ));
         }
 
-        let mut auth_string = Vec::from(auth_string);
-        let user_email = String::from(user_email);
+        let auth_string = Zeroizing::new(Vec::from(auth_string));
 
         let mut auth_dao = db::auth::Dao::new(db_thread_pool);
         let hash =
@@ -158,8 +153,6 @@ pub mod verification {
                 argon2_kdf::Secret::using_bytes(&env::CONF.keys.hashing_key),
             );
 
-            auth_string.zeroize();
-
             sender
                 .send(Ok(does_auth_string_match_hash))
                 .expect("Sending to channel failed");
@@ -380,23 +373,25 @@ pub mod test_utils {
     use entries_utils::models::budget::Budget;
     use entries_utils::models::user::User;
     use entries_utils::request_io::{
-        InputBudget, InputCategoryWithTempId, InputUser, OutputBudgetFrame,
+        InputBudget, InputCategoryWithTempId, InputUser, OutputBudgetFrame, UserInvitationToBudget,
     };
     use entries_utils::schema::budgets::dsl::budgets;
     use entries_utils::schema::users as user_fields;
     use entries_utils::schema::users::dsl::users;
     use entries_utils::token::auth_token::{AuthToken, AuthTokenType};
+    use entries_utils::token::budget_access_token::BudgetAccessTokenInternalClaims;
 
     use actix_web::http::StatusCode;
     use actix_web::test::{self, TestRequest};
     use actix_web::web::Data;
     use actix_web::App;
     use diesel::{dsl, ExpressionMethods, QueryDsl, RunQueryDsl};
-    use ed25519::SigningKey;
+    use ed25519::{Signer, SigningKey};
     use ed25519_dalek as ed25519;
     use rand::rngs::OsRng;
     use rand::Rng;
-    use std::time::SystemTime;
+    use std::time::{Duration, SystemTime, UNIX_EPOCH};
+    use uuid::Uuid;
 
     use crate::env;
 
@@ -406,6 +401,25 @@ pub mod test_utils {
             .collect()
     }
 
+    pub fn gen_budget_token(budget_id: Uuid, key_id: Uuid) -> String {
+        let exp = SystemTime::now() + Duration::from_secs(10);
+        let exp = exp.duration_since(UNIX_EPOCH).unwrap().as_secs();
+
+        let claims = BudgetAccessTokenInternalClaims {
+            kid: key_id,
+            bid: budget_id,
+            exp,
+        };
+
+        let claims = serde_json::to_vec(&claims).unwrap();
+
+        let key_pair = ed25519::SigningKey::generate(&mut OsRng);
+        let signature = hex::encode(&key_pair.sign(&claims).to_bytes());
+
+        let claims = String::from_utf8_lossy(&claims);
+        base64::encode_config(format!("{claims}|{signature}"), base64::URL_SAFE_NO_PAD)
+    }
+
     pub async fn create_user() -> (User, String) {
         let app = test::init_service(
             App::new()
@@ -478,7 +492,7 @@ pub mod test_utils {
         (user, access_token)
     }
 
-    pub async fn create_budget(access_token: &str) -> (Budget, SigningKey) {
+    pub async fn create_budget(access_token: &str) -> (Budget, SigningKey, Uuid) {
         let app = test::init_service(
             App::new()
                 .app_data(Data::new(env::testing::DB_THREAD_POOL.clone()))
@@ -524,4 +538,44 @@ pub mod test_utils {
 
         (budget, key_pair)
     }
+
+    pub async fn share_budget(
+        budget_id: Uuid,
+        recipient_email: &str,
+        read_only: bool,
+        budget_access_token: &str,
+        user_access_token: &str,
+    ) {
+        let app = test::init_service(
+            App::new()
+                .app_data(Data::new(env::testing::DB_THREAD_POOL.clone()))
+                .app_data(Data::from(env::testing::SMTP_THREAD_POOL.clone()))
+                .configure(crate::services::api::configure),
+        )
+        .await;
+
+        let invite_info = UserInvitationToBudget {
+            recipient_user_email: String::from(recipient_email),
+            sender_public_key: gen_bytes(22),
+            encryption_key_encrypted: gen_bytes(44),
+            budget_info_encrypted: gen_bytes(20),
+            sender_info_encrypted: gen_bytes(30),
+            share_info_symmetric_key_encrypted: gen_bytes(35),
+            expiration: SystemTime::now() + Duration::from_secs(10),
+            read_only,
+        };
+
+        let req = TestRequest::put()
+            .uri("/api/budget/invite_user")
+            .insert_header(("AccessToken", user_access_token))
+            .insert_header(("BudgetAccessToken", budget_access_token))
+            .insert_header(("AppVersion", "0.1.0"))
+            .set_json(&invite_info)
+            .to_request();
+        test::call_service(&app, req).await;
+
+        // TODO: Recipient gets all invites
+        // TODO: Recipient accepts invite
+        // TODO: Recipient
+    }
 }
diff --git a/entries-server/src/handlers/user.rs b/entries-server/src/handlers/user.rs
index 9e83e8d..a500162 100644
--- a/entries-server/src/handlers/user.rs
+++ b/entries-server/src/handlers/user.rs
@@ -332,8 +332,8 @@ pub async fn change_password(
     }
 
     handlers::verification::verify_otp(
-        &new_password_data.otp,
-        &new_password_data.user_email,
+        Arc::clone(&new_password_data.otp),
+        Arc::clone(&new_password_data.user_email),
         &db_thread_pool,
     )
     .await?;
@@ -412,8 +412,8 @@ pub async fn change_recovery_key(
         .await?;
 
     handlers::verification::verify_otp(
-        &new_recovery_key_data.otp,
-        &user_access_token.0.user_email,
+        Arc::clone(&new_recovery_key_data.otp),
+        user_access_token.0.user_email.into(),
         &db_thread_pool,
     )
     .await?;
@@ -1478,6 +1478,7 @@ pub mod tests {
         .await;
 
         let (user, access_token) = test_utils::create_user().await;
+        let (budget, budget_key_pair) = test_utils::create_budget(&access_token).await;
 
         // TODO: Test with 0 tokens
         // TODO: Test with 2 tokens
diff --git a/entries-utils/Cargo.toml b/entries-utils/Cargo.toml
index ded914a..bf3c609 100644
--- a/entries-utils/Cargo.toml
+++ b/entries-utils/Cargo.toml
@@ -17,7 +17,7 @@ log = "0.4"
 num_cpus = "1.15"
 rand = "0.8"
 r2d2 = "0.8"
-serde = { version = "1.0", features = ["derive"] }
+serde = { version = "1.0", features = ["derive", "rc"] }
 serde_json = "1.0"
 serde_with = { version = "3.0", features = ["base64", "hex"] }
 sha1 = "0.10"
diff --git a/entries-utils/src/request_io/inputs.rs b/entries-utils/src/request_io/inputs.rs
index 06fa211..33f40c6 100644
--- a/entries-utils/src/request_io/inputs.rs
+++ b/entries-utils/src/request_io/inputs.rs
@@ -2,14 +2,17 @@ use serde::{Deserialize, Serialize};
 use serde_with::base64::Base64;
 use serde_with::hex::Hex;
 use serde_with::serde_as;
+use std::sync::Arc;
 use std::time::SystemTime;
 use uuid::Uuid;
-use zeroize::{Zeroize, ZeroizeOnDrop};
+use zeroize::ZeroizeOnDrop;
 
 #[serde_as]
-#[derive(Clone, Debug, Deserialize, Serialize, Zeroize, ZeroizeOnDrop)]
+#[derive(Clone, Debug, Deserialize, Serialize, ZeroizeOnDrop)]
 pub struct CredentialPair {
-    pub email: String,
+    #[zeroize(skip)]
+    pub email: Arc<str>,
+
     #[serde_as(as = "Base64")]
     pub auth_string: Vec<u8>,
     pub nonce: i32,
@@ -17,7 +20,7 @@ pub struct CredentialPair {
 
 #[derive(Clone, Debug, Deserialize, Serialize)]
 pub struct InputEmail {
-    pub email: String,
+    pub email: Arc<str>,
 }
 
 #[derive(Clone, Debug, Deserialize, Serialize)]
@@ -43,109 +46,123 @@ pub struct InputDateRange {
 }
 
 #[serde_as]
-#[derive(Clone, Debug, Deserialize, Serialize, Zeroize, ZeroizeOnDrop)]
+#[derive(Clone, Debug, Deserialize, Serialize, ZeroizeOnDrop)]
 pub struct InputUser {
-    pub email: String,
+    #[zeroize(skip)]
+    pub email: Arc<str>,
 
     #[serde_as(as = "Base64")]
     pub auth_string: Vec<u8>,
 
     #[serde_as(as = "Base64")]
-    pub auth_string_salt: Vec<u8>,
+    #[zeroize(skip)]
+    pub auth_string_salt: Arc<[u8]>,
     pub auth_string_memory_cost_kib: i32,
     pub auth_string_parallelism_factor: i32,
     pub auth_string_iters: i32,
 
     #[serde_as(as = "Base64")]
-    pub password_encryption_salt: Vec<u8>,
+    #[zeroize(skip)]
+    pub password_encryption_salt: Arc<[u8]>,
     pub password_encryption_memory_cost_kib: i32,
     pub password_encryption_parallelism_factor: i32,
     pub password_encryption_iters: i32,
 
     #[serde_as(as = "Base64")]
-    pub recovery_key_salt: Vec<u8>,
+    #[zeroize(skip)]
+    pub recovery_key_salt: Arc<[u8]>,
     pub recovery_key_memory_cost_kib: i32,
     pub recovery_key_parallelism_factor: i32,
     pub recovery_key_iters: i32,
 
     #[serde_as(as = "Base64")]
-    pub encryption_key_encrypted_with_password: Vec<u8>,
+    #[zeroize(skip)]
+    pub encryption_key_encrypted_with_password: Arc<[u8]>,
     #[serde_as(as = "Base64")]
-    pub encryption_key_encrypted_with_recovery_key: Vec<u8>,
+    #[zeroize(skip)]
+    pub encryption_key_encrypted_with_recovery_key: Arc<[u8]>,
 
     #[serde_as(as = "Base64")]
-    pub public_key: Vec<u8>,
+    #[zeroize(skip)]
+    pub public_key: Arc<[u8]>,
 
     #[serde_as(as = "Base64")]
-    pub preferences_encrypted: Vec<u8>,
+    #[zeroize(skip)]
+    pub preferences_encrypted: Arc<[u8]>,
     #[serde_as(as = "Base64")]
-    pub user_keystore_encrypted: Vec<u8>,
+    #[zeroize(skip)]
+    pub user_keystore_encrypted: Arc<[u8]>,
 }
 
 #[serde_as]
 #[derive(Clone, Debug, Deserialize, Serialize)]
 pub struct InputEditUserPrefs {
     #[serde_as(as = "Base64")]
-    pub encrypted_blob: Vec<u8>,
+    pub encrypted_blob: Arc<[u8]>,
     #[serde_as(as = "Hex")]
-    pub expected_previous_data_hash: Vec<u8>,
+    pub expected_previous_data_hash: Arc<[u8]>,
 }
 
 #[serde_as]
 #[derive(Clone, Debug, Deserialize, Serialize)]
 pub struct InputEditUserKeystore {
     #[serde_as(as = "Base64")]
-    pub encrypted_blob: Vec<u8>,
+    pub encrypted_blob: Arc<[u8]>,
     #[serde_as(as = "Hex")]
-    pub expected_previous_data_hash: Vec<u8>,
+    pub expected_previous_data_hash: Arc<[u8]>,
 }
 
 #[derive(Clone, Debug, Deserialize, Serialize)]
 pub struct InputOtp {
-    pub otp: String,
+    pub otp: Arc<str>,
 }
 
 #[serde_as]
-#[derive(Clone, Debug, Deserialize, Serialize, Zeroize, ZeroizeOnDrop)]
+#[derive(Clone, Debug, Deserialize, Serialize, ZeroizeOnDrop)]
 pub struct InputNewAuthStringAndEncryptedPassword {
-    pub user_email: String,
-    pub otp: String,
+    #[zeroize(skip)]
+    pub user_email: Arc<str>,
+    #[zeroize(skip)]
+    pub otp: Arc<str>,
 
     #[serde_as(as = "Base64")]
     pub new_auth_string: Vec<u8>,
 
     #[serde_as(as = "Base64")]
-    pub auth_string_salt: Vec<u8>,
-
+    #[zeroize(skip)]
+    pub auth_string_salt: Arc<[u8]>,
     pub auth_string_memory_cost_kib: i32,
     pub auth_string_parallelism_factor: i32,
     pub auth_string_iters: i32,
 
     #[serde_as(as = "Base64")]
-    pub password_encryption_salt: Vec<u8>,
-
+    #[zeroize(skip)]
+    pub password_encryption_salt: Arc<[u8]>,
     pub password_encryption_memory_cost_kib: i32,
     pub password_encryption_parallelism_factor: i32,
     pub password_encryption_iters: i32,
 
     #[serde_as(as = "Base64")]
-    pub encrypted_encryption_key: Vec<u8>,
+    #[zeroize(skip)]
+    pub encrypted_encryption_key: Arc<[u8]>,
 }
 
 #[serde_as]
-#[derive(Clone, Debug, Deserialize, Serialize, Zeroize, ZeroizeOnDrop)]
+#[derive(Clone, Debug, Deserialize, Serialize, ZeroizeOnDrop)]
 pub struct InputNewRecoveryKey {
-    pub otp: String,
+    #[zeroize(skip)]
+    pub otp: Arc<str>,
 
     #[serde_as(as = "Base64")]
-    pub recovery_key_salt: Vec<u8>,
-
+    #[zeroize(skip)]
+    pub recovery_key_salt: Arc<[u8]>,
     pub recovery_key_memory_cost_kib: i32,
     pub recovery_key_parallelism_factor: i32,
     pub recovery_key_iters: i32,
 
     #[serde_as(as = "Base64")]
-    pub encrypted_encryption_key: Vec<u8>,
+    #[zeroize(skip)]
+    pub encrypted_encryption_key: Arc<[u8]>,
 }
 
 // temp_id is an ID the client generates that allows the server to differentiate between
@@ -157,49 +174,48 @@ pub struct InputCategoryWithTempId {
     pub temp_id: i32,
 
     #[serde_as(as = "Base64")]
-    pub encrypted_blob: Vec<u8>,
+    pub encrypted_blob: Arc<[u8]>,
 }
 
 #[serde_as]
 #[derive(Clone, Debug, Deserialize, Serialize)]
 pub struct InputBudget {
     #[serde_as(as = "Base64")]
-    pub encrypted_blob: Vec<u8>,
+    pub encrypted_blob: Arc<[u8]>,
 
     #[serde_as(as = "Base64")]
-    pub encryption_key_encrypted: Vec<u8>,
-
+    pub encryption_key_encrypted: Arc<[u8]>,
     pub categories: Vec<InputCategoryWithTempId>,
 
     #[serde_as(as = "Base64")]
-    pub user_public_budget_key: Vec<u8>,
+    pub user_public_budget_key: Arc<[u8]>,
 }
 
 #[serde_as]
 #[derive(Clone, Debug, Deserialize, Serialize)]
 pub struct InputEditBudget {
     #[serde_as(as = "Base64")]
-    pub encrypted_blob: Vec<u8>,
+    pub encrypted_blob: Arc<[u8]>,
     #[serde_as(as = "Hex")]
-    pub expected_previous_data_hash: Vec<u8>,
+    pub expected_previous_data_hash: Arc<[u8]>,
 }
 
 #[serde_as]
 #[derive(Clone, Debug, Deserialize, Serialize)]
 pub struct UserInvitationToBudget {
-    pub recipient_user_email: String,
+    pub recipient_user_email: Arc<str>,
     #[serde_as(as = "Base64")]
-    pub sender_public_key: Vec<u8>,
+    pub sender_public_key: Arc<[u8]>,
 
     #[serde_as(as = "Base64")]
-    pub encryption_key_encrypted: Vec<u8>,
+    pub encryption_key_encrypted: Arc<[u8]>,
 
     #[serde_as(as = "Base64")]
-    pub budget_info_encrypted: Vec<u8>,
+    pub budget_info_encrypted: Arc<[u8]>,
     #[serde_as(as = "Base64")]
-    pub sender_info_encrypted: Vec<u8>,
+    pub sender_info_encrypted: Arc<[u8]>,
     #[serde_as(as = "Base64")]
-    pub share_info_symmetric_key_encrypted: Vec<u8>,
+    pub share_info_symmetric_key_encrypted: Arc<[u8]>,
 
     pub expiration: SystemTime,
     pub read_only: bool,
@@ -214,14 +230,14 @@ pub struct InputEntryId {
 #[derive(Clone, Debug, Deserialize, Serialize)]
 pub struct InputEncryptedBlob {
     #[serde_as(as = "Base64")]
-    pub encrypted_blob: Vec<u8>,
+    pub encrypted_blob: Arc<[u8]>,
 }
 
 #[serde_as]
 #[derive(Clone, Debug, Deserialize, Serialize)]
 pub struct InputEncryptedBlobAndCategoryId {
     #[serde_as(as = "Base64")]
-    pub encrypted_blob: Vec<u8>,
+    pub encrypted_blob: Arc<[u8]>,
     pub category_id: Option<Uuid>,
 }
 
@@ -229,9 +245,9 @@ pub struct InputEncryptedBlobAndCategoryId {
 #[derive(Clone, Debug, Deserialize, Serialize)]
 pub struct InputEntryAndCategory {
     #[serde_as(as = "Base64")]
-    pub entry_encrypted_blob: Vec<u8>,
+    pub entry_encrypted_blob: Arc<[u8]>,
     #[serde_as(as = "Base64")]
-    pub category_encrypted_blob: Vec<u8>,
+    pub category_encrypted_blob: Arc<[u8]>,
 }
 
 #[serde_as]
@@ -239,9 +255,9 @@ pub struct InputEntryAndCategory {
 pub struct InputEditEntry {
     pub entry_id: Uuid,
     #[serde_as(as = "Base64")]
-    pub encrypted_blob: Vec<u8>,
+    pub encrypted_blob: Arc<[u8]>,
     #[serde_as(as = "Hex")]
-    pub expected_previous_data_hash: Vec<u8>,
+    pub expected_previous_data_hash: Arc<[u8]>,
     pub category_id: Option<Uuid>,
 }
 
@@ -256,9 +272,9 @@ pub struct InputEditCategory {
     pub category_id: Uuid,
 
     #[serde_as(as = "Base64")]
-    pub encrypted_blob: Vec<u8>,
+    pub encrypted_blob: Arc<[u8]>,
     #[serde_as(as = "Hex")]
-    pub expected_previous_data_hash: Vec<u8>,
+    pub expected_previous_data_hash: Arc<[u8]>,
 }
 
 #[derive(Clone, Debug, Deserialize, Serialize)]
@@ -275,10 +291,10 @@ pub struct InputBudgetAccessTokenList {
 #[derive(Clone, Debug, Deserialize, Serialize)]
 pub struct InputPublicKey {
     #[serde_as(as = "Base64")]
-    pub public_key: Vec<u8>,
+    pub public_key: Arc<[u8]>,
 }
 
 #[derive(Clone, Debug, Deserialize, Serialize)]
 pub struct InputBackupCode {
-    pub code: String,
+    pub code: Arc<str>,
 }
diff --git a/entries-utils/src/token/budget_access_token.rs b/entries-utils/src/token/budget_access_token.rs
index 62687a6..179dd72 100644
--- a/entries-utils/src/token/budget_access_token.rs
+++ b/entries-utils/src/token/budget_access_token.rs
@@ -84,12 +84,12 @@ mod tests {
 
         let claims = BudgetAccessTokenInternalClaims { kid, bid, exp };
         let claims = serde_json::to_vec(&claims).unwrap();
-        let claims = String::from_utf8_lossy(&claims);
 
         let keypair = Keypair::generate(&mut OsRng {});
         let pub_key = keypair.public.as_bytes();
-        let signature = hex::encode(keypair.sign(claims.as_bytes()));
+        let signature = hex::encode(keypair.sign(&claims));
 
+        let claims = String::from_utf8_lossy(&claims);
         let token = base64::encode_config(format!("{claims}|{signature}"), base64::URL_SAFE_NO_PAD);
 
         let token = BudgetAccessToken::from_str(&token).unwrap();
