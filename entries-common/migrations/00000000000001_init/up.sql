CREATE TABLE users (
    id UUID PRIMARY KEY,

    email TEXT UNIQUE NOT NULL,
    is_verified BOOLEAN NOT NULL,

    public_key_id UUID NOT NULL,
    public_key BYTEA NOT NULL,

    created_timestamp TIMESTAMP NOT NULL,

    auth_string_hash TEXT NOT NULL,

    auth_string_hash_salt BYTEA NOT NULL,
    auth_string_hash_mem_cost_kib INT NOT NULL,
    auth_string_hash_threads INT NOT NULL,
    auth_string_hash_iterations INT NOT NULL,

    password_encryption_key_salt BYTEA NOT NULL,
    password_encryption_key_mem_cost_kib INT NOT NULL,
    password_encryption_key_threads INT NOT NULL,
    password_encryption_key_iterations INT NOT NULL,

    -- Recovery key gets hashed on the client twice with different salts. One hash is used
    -- to encrypt the account encryption key so it can be recovered. This hash is NOT sent
    -- to the server (but the encryption key it encrypts is). The other hash is used as an
    -- auth string to authenticate with the server in the recovery flow. This hash IS sent
    -- to the server and the server then rehashes it for storage using the same parameters
    -- used to hash the auth string (but with a different salt).
    recovery_key_hash_salt_for_encryption BYTEA NOT NULL,
    recovery_key_hash_salt_for_recovery_auth BYTEA NOT NULL,
    recovery_key_hash_mem_cost_kib INT NOT NULL,
    recovery_key_hash_threads INT NOT NULL,
    recovery_key_hash_iterations INT NOT NULL,

    recovery_key_auth_hash_rehashed_with_auth_string_params TEXT NOT NULL,

    encryption_key_encrypted_with_password BYTEA NOT NULL,
    encryption_key_encrypted_with_recovery_key BYTEA NOT NULL,

    CONSTRAINT chk_email_length CHECK (char_length(email) <= 255),
    CONSTRAINT chk_auth_string_hash_length CHECK (char_length(auth_string_hash) <= 128),
    CONSTRAINT chk_recovery_key_auth_hash_rehashed_with_auth_string_params_length CHECK (char_length(recovery_key_auth_hash_rehashed_with_auth_string_params) <= 128)
);

CREATE TABLE blacklisted_tokens (
    token_signature BYTEA PRIMARY KEY,
    token_expiration TIMESTAMP NOT NULL
);

CREATE INDEX idx_blacklisted_tokens_token_signature ON blacklisted_tokens(token_signature);

CREATE TABLE budgets (
    id UUID PRIMARY KEY,
    encrypted_blob BYTEA NOT NULL,
    version_nonce BIGINT NOT NULL,
    modified_timestamp TIMESTAMP NOT NULL
);

-- These accept keys allow the server to verify that the user with the private key has
-- permission to join a budget. Because this table purposefully doesn't store an invitation ID,
-- a user can specify the wrong accept key when accepting a budget share. However, they are
-- limited to accepting their OWN invitations as the email address in their auth token must
-- match what is recorded with the invitation and only their public RSA key can decrypt the
-- budget encryption key.
CREATE TABLE budget_accept_keys (
    key_id UUID UNIQUE NOT NULL,
    budget_id UUID NOT NULL,

    public_key BYTEA NOT NULL, -- Ed25519

    expiration TIMESTAMP NOT NULL,
    read_only BOOLEAN NOT NULL,

    PRIMARY KEY (key_id, budget_id),
    CONSTRAINT fk_budget_accept_keys_budget_key FOREIGN KEY(budget_id) REFERENCES budgets(id) ON DELETE CASCADE
);

CREATE INDEX idx_budget_accept_keys_budget_id ON budget_accept_keys(budget_id);
CREATE INDEX idx_budget_accept_keys_key_id ON budget_accept_keys(key_id);

CREATE TABLE budget_access_keys (
    key_id UUID UNIQUE NOT NULL,
    budget_id UUID NOT NULL,
    public_key BYTEA NOT NULL, -- Ed25519
    read_only BOOLEAN NOT NULL,

    PRIMARY KEY (key_id, budget_id),
    CONSTRAINT fk_budget_access_keys_budget_key FOREIGN KEY(budget_id) REFERENCES budgets(id) ON DELETE CASCADE
);

CREATE INDEX idx_budget_access_keys_budget_id ON budget_access_keys(budget_id);

CREATE TABLE budget_share_invites (
    id UUID PRIMARY KEY,

    recipient_user_email TEXT NOT NULL,
    -- The sender can sign a token to prove to the server that they are authorized to
    -- retract/delete a budget_share_invite
    sender_public_key BYTEA NOT NULL, -- Ed25519

    -- Encrypted with recipient's public key. This should never get sent to the recipient user
    -- until the invite has been accepted
    encryption_key_encrypted BYTEA NOT NULL,
    -- The private key the recipient can use to certify they are able to accept the invitation
    -- and join the budget. Generated by the server, encrypted with recipient's public key.
    -- The corresponding public key is in the budget_accept_keys table.
    --
    -- The server could verify the recipient with their auth token without the user needing to
    -- sign a challenge using this private key. However, the use of the private key allows the
    -- server to avoid storing the budget_id together with the invitation.
    budget_accept_private_key_encrypted BYTEA NOT NULL,

    -- Budget info includes the budget ID, budget name, etc.
    budget_info_encrypted BYTEA NOT NULL,
    -- Sender info includes the sender's name and email address
    sender_info_encrypted BYTEA NOT NULL,
    -- Information about the budget_accept_private_key, such as its expiration, whether it is
    -- read-only, etc
    budget_accept_key_info_encrypted BYTEA NOT NULL,
    -- The server generates this and encrypts it with with the recipient's public RSA key so
    -- the server can forget about the association.
    budget_accept_key_id_encrypted BYTEA NOT NULL,
    -- The symmetric key that is used to encrypt the *_info_encrypted fields above, encrypted
    -- with the recipient's public key. This should be sent to the user even *before* the user
    -- accepts the invitation (the user needs to decrypt the info fields)
    share_info_symmetric_key_encrypted BYTEA NOT NULL,

    -- ID of the invite recipient's public RSA key the sender used to encrypt the symmetric key
    -- and other info about the budget and sender
    recipient_public_key_id_used_by_sender UUID NOT NULL,
    -- ID of the invite recipient's public RSA key the server used to encrypt the accept key
    recipient_public_key_id_used_by_server UUID NOT NULL,

    -- The UNIX timestamp of creation, integer-divided by 5 million seconds. The purpose of
    -- storing this is to allow the server to delete 2-month/3-month old invites without being
    -- able to associate them with the expiration time of a budget_share_key
    created_unix_timestamp_intdiv_five_million SMALLINT NOT NULL,

    CONSTRAINT fk_budget_share_invites_recipient_key FOREIGN KEY(recipient_user_email) REFERENCES users(email) ON DELETE CASCADE ON UPDATE CASCADE,
    CONSTRAINT chk_recipient_user_email_length CHECK (char_length(recipient_user_email) <= 255)
);

CREATE INDEX idx_budget_share_invites_recipient_user_email ON budget_share_invites(recipient_user_email);

CREATE TABLE categories (
    id UUID PRIMARY KEY,
    budget_id UUID NOT NULL,

    encrypted_blob BYTEA NOT NULL,
    version_nonce BIGINT NOT NULL,

    modified_timestamp TIMESTAMP NOT NULL,

    CONSTRAINT fk_categories_budget_key FOREIGN KEY(budget_id) REFERENCES budgets(id) ON DELETE CASCADE
);

CREATE INDEX idx_categories_budget_id ON categories(budget_id);

CREATE TABLE entries (
    id UUID PRIMARY KEY,
    budget_id UUID NOT NULL,

    category_id UUID, -- Intentionally nullable

    encrypted_blob BYTEA NOT NULL,
    version_nonce BIGINT NOT NULL,

    modified_timestamp TIMESTAMP NOT NULL,

    CONSTRAINT fk_entries_budget_key FOREIGN KEY(budget_id) REFERENCES budgets(id) ON DELETE CASCADE,
    CONSTRAINT fk_entries_category_key FOREIGN KEY(category_id) REFERENCES categories(id) ON DELETE SET NULL
);

CREATE INDEX idx_entries_budget_id ON entries(budget_id);
CREATE INDEX idx_entries_category_id ON entries(category_id);

CREATE TABLE job_registry (
    job_name TEXT PRIMARY KEY,
    last_run_timestamp TIMESTAMP NOT NULL
);

CREATE TABLE signin_nonces (
    user_email TEXT PRIMARY KEY,
    nonce INT NOT NULL,

    CONSTRAINT fk_signin_nonces_user_key FOREIGN KEY(user_email) REFERENCES users(email) ON DELETE CASCADE ON UPDATE CASCADE,
    CONSTRAINT chk_user_email_length CHECK (char_length(user_email) <= 255)
);

CREATE INDEX idx_signin_nonces_user_email ON signin_nonces(user_email);



CREATE TABLE user_deletion_requests (
    user_id UUID PRIMARY KEY,
    ready_for_deletion_time TIMESTAMP NOT NULL,

    CONSTRAINT fk_user_deletion_requests_user_key FOREIGN KEY(user_id) REFERENCES users(id) ON DELETE CASCADE
);

CREATE INDEX idx_user_deletion_requests_user_id ON user_deletion_requests(user_id);

CREATE TABLE user_deletion_request_budget_keys (
    key_id UUID PRIMARY KEY,
    -- Using a users table key rather than user_deletion_requests table key so that these
    -- records may be created before the deletion request (the deletion request doesn't get
    -- created until a user verifies via a link sent to their email). This table may be queried
    -- using data available in an auth token, like the user_id. This table can be related to
    -- the user_deletion_requests table indirectly by joining on user_id for both tables.
    user_id UUID NOT NULL,
    -- This record should be deleted after this time
    delete_me_time TIMESTAMP NOT NULL,

    CONSTRAINT fk_user_deletion_request_budget_keys_user_key FOREIGN KEY(user_id) REFERENCES users(id) ON DELETE CASCADE,
    CONSTRAINT fk_user_deletion_request_budget_keys_key_key FOREIGN KEY(key_id) REFERENCES budget_access_keys(key_id) ON DELETE CASCADE
);

CREATE INDEX idx_user_deletion_request_budget_keys_user_id ON user_deletion_request_budget_keys(user_id);
CREATE INDEX idx_user_deletion_request_budget_keys_delete_me_time ON user_deletion_request_budget_keys(delete_me_time);

CREATE TABLE user_keystores (
    user_id UUID PRIMARY KEY,
    encrypted_blob BYTEA NOT NULL,
    version_nonce BIGINT NOT NULL,

    CONSTRAINT fk_user_keystores_user_key FOREIGN KEY(user_id) REFERENCES users(id) ON DELETE CASCADE
);

CREATE INDEX idx_user_keystores_user_id ON user_keystores(user_id);

CREATE TABLE user_otps (
    user_email TEXT PRIMARY KEY,
    otp CHAR(8) NOT NULL,
    expiration TIMESTAMP NOT NULL,

    CONSTRAINT fk_user_otps_user_key FOREIGN KEY(user_email) REFERENCES users(email) ON DELETE CASCADE ON UPDATE CASCADE,
    CONSTRAINT chk_user_email_length CHECK (char_length(user_email) <= 255)
);

CREATE INDEX idx_user_otps_user_email_and_otp ON user_otps(user_email, otp);

CREATE TABLE user_preferences (
    user_id UUID PRIMARY KEY,
    encrypted_blob BYTEA NOT NULL,
    version_nonce BIGINT NOT NULL,

    CONSTRAINT fk_user_preferences_user_key FOREIGN KEY(user_id) REFERENCES users(id) ON DELETE CASCADE
);

CREATE INDEX idx_user_preferences_user_id ON user_preferences(user_id);
